<!DOCTYPE html>
<html>
<head>
<!-- 2016-06-09 Thu 17:12 -->
<meta  charset="utf-8">
<meta  name="viewport" content="width=device-width, initial-scale=1">
<title>A Compact React Cookbook</title>
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Jichao Ouyang">
<link rel="apple-touch-icon" sizes="114x114" href="/assets/apple-icon-114x114.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="manifest" href="/assets/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/assets/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/pixyll.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="http://blog.oyanglul.us/index.xml"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css" />
<!--[if lt IE 9]>
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.ie.min.css" />
     <![endif]--> 
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="/~jichao.ouyang.html"> HOME </a>
</div><div id="content">
<header>
<h1 class="title">A Compact React Cookbook</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline5">1. Why not 2 way binding/为毛不用双向绑定</a>
<ul>
<li><a href="#orgheadline1">1.1. 双向绑定</a></li>
<li><a href="#orgheadline2">1.2. 单向绑定</a></li>
<li><a href="#orgheadline3">1.3. 双向有什么不好</a></li>
<li><a href="#orgheadline4">1.4. 单向有什么好</a></li>
</ul>
</li>
<li><a href="#orgheadline8">2. What's Virtual DOM, why should we care / 为毛要用 Vitual Dom</a>
<ul>
<li><a href="#orgheadline6">2.1. 以前是如何操作 DOM 的 （Mutable）</a></li>
<li><a href="#orgheadline7">2.2. Virtual DOM （Immutable）</a></li>
</ul>
</li>
<li><a href="#orgheadline15">3. Why Immutable        / 为毛要不可变</a>
<ul>
<li><a href="#orgheadline9">3.1. 状态</a></li>
<li><a href="#orgheadline10">3.2. Class</a></li>
<li><a href="#orgheadline14">3.3. 让你的数据结构 immutable 的工具们</a>
<ul>
<li><a href="#orgheadline11">Immutablility helper</a></li>
<li><a href="#orgheadline12">mori</a></li>
<li><a href="#orgheadline13">Immutable.js</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline19">4. How to do Unit test React project        /  如何单元测试</a>
<ul>
<li><a href="#orgheadline16">4.1. Jest</a></li>
<li><a href="#orgheadline17">4.2. jasmine</a></li>
<li><a href="#orgheadline18">4.3. mocha</a></li>
</ul>
</li>
<li><a href="#orgheadline22">5. Modular and Components</a>
<ul>
<li><a href="#orgheadline20">5.1. browserify</a></li>
<li><a href="#orgheadline21">5.2. webpack</a></li>
</ul>
</li>
<li><a href="#orgheadline23">6. How should I thinking in react way / 如何以 React 的方式解决问题</a></li>
<li><a href="#orgheadline27">7. What about Data Fetching / 只有 V 的话，数据 M 呢</a>
<ul>
<li><a href="#orgheadline24">7.1. just rest</a></li>
<li><a href="#orgheadline25">7.2. relay/graphql</a></li>
<li><a href="#orgheadline26">7.3. falcor</a></li>
</ul>
</li>
<li><a href="#orgheadline32">8. What about Router / router 怎么办</a>
<ul>
<li><a href="#orgheadline30">8.1. direactor</a>
<ul>
<li><a href="#orgheadline28">client side</a></li>
<li><a href="#orgheadline29">server side</a></li>
</ul>
</li>
<li><a href="#orgheadline31">8.2. react router</a></li>
</ul>
</li>
<li><a href="#orgheadline39">9. How to communicate between two components that don't have a parent-child relationship/ 不是父子关系的 component 怎么交互</a>
<ul>
<li><a href="#orgheadline33">9.1. event</a></li>
<li><a href="#orgheadline36">9.2. flux</a>
<ul>
<li><a href="#orgheadline34">dispatcher</a></li>
<li><a href="#orgheadline35">store</a></li>
</ul>
</li>
<li><a href="#orgheadline37">9.3. router</a></li>
<li><a href="#orgheadline38">9.4. 应用级别 state</a></li>
</ul>
</li>
<li><a href="#orgheadline40">10. When should I use "key" / 什么时候该用 key</a></li>
<li><a href="#orgheadline41">11. What's these Warnings / 这些黄黄的是神马</a></li>
<li><a href="#orgheadline45">12. How to Profile Component Perfomance / 如何提升效率</a>
<ul>
<li><a href="#orgheadline42">12.1. react profile</a></li>
<li><a href="#orgheadline43">12.2. PureRenderMixin</a></li>
<li><a href="#orgheadline44">12.3. shouldComponentUpdate</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
这是一本非常 campact 的 React 煮书，收集了在实践 React 时的一些问题和解决方法。
</p>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><span class="section-number-2">1</span> Why not 2 way binding/为毛不用双向绑定</h2>
<div class="outline-text-2" id="text-1">
<p>
解释这个问题我们需要先看什么是双向绑定，什么是单向绑定
</p>


<figure>
<p><img src="./images/multi-recur.gif" alt="multi-recur.gif">
</p>
</figure>
</div>

<div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> 双向绑定</h3>
<div class="outline-text-3" id="text-1-1">
<p>
也就是dom 上的 value 与 controller 或者 view controller 上的绑定，值保持一致。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> 单向绑定</h3>
<div class="outline-text-3" id="text-1-2">
<p>
dom 上的值来源于 controller，但是 dom 上的值改变不会改变 controller 上的值。
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.3</span> 双向有什么不好<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>perfomance</li>
<li>我们真的需要吗？实际上有多少值是真的需要双向绑的</li>
<li>到底谁动了我的值？too many sources of truth</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.4</span> 单向有什么好</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>只有一个 source of truth,  代码好 reason about</li>
<li>更快</li>
<li>需要的时候自己绑一把，也并不是多麻烦的事</li>
</ul>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">TwoWayBindingInput</span> = React.createClass({
  <span style="color: #6a5acd;">getInitialState</span>: <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">return</span> {message: <span style="color: #8b0000;">'Hello!'</span>};
  },
  <span style="color: #6a5acd;">handleChange</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">event</span>) {
<span id="coderef-setstate" class="coderef-off">    <span style="color: #6b8e23;">this</span>.setState({message: event.target.value}); <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&lt;=</span> (setstate)</span>
  },
  <span style="color: #6a5acd;">render</span>: <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">message</span> = <span style="color: #6b8e23;">this</span>.state.message;
<span id="coderef-value" class="coderef-off">    <span style="color: #00008b;">return</span> &lt;input type=<span style="color: #8b0000;">"text"</span> value={message} onChange={<span style="color: #6b8e23;">this</span>.handleChange} /&gt;; <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&lt;=</span> (value)</span>
  }
});
</pre>
</div>

<p>
注意看这个双向绑定，<a href="#coderef-value"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-value');" onmouseout="CodeHighlightOff(this, 'coderef-value');">第value行</a> 是单向绑定值 <code>message</code> 到 <code>input</code> 元素上，<a href="#coderef-setstate"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-setstate');" onmouseout="CodeHighlightOff(this, 'coderef-setstate');">第setstate行</a> 是把 <code>input</code> 元素的值绑定回来，但是 <b>注意看</b> 这里绑定回来需要通过 <code>setState</code> 来完成，这就保证了 React Component 的 source of truth 还是只有 state。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">2</span> What's Virtual DOM, why should we care / 为毛要用 Vitual Dom</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">2.1</span> 以前是如何操作 DOM 的 （Mutable）</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>query 到 DOM 上一个元素</li>
<li>改吧改吧</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">2.2</span> Virtual DOM （Immutable）</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>想好要往 DOM 上放什么东西</li>
<li>把它给 Virtual DOM</li>
<li><p>
Virtual DOM 决定哪些应该修改 DOM 哪些不用
</p>

<p>
为什么说前者是 Mutable 后者是 Immutable，这是相对你的业务逻辑来说的。
</p></li>
</ol>
<p>
DOM 本身是 Mutable 的东西，把它柔和到你的业务上给你的逻辑加上了不少 mutable 的因素，而 Virtual DOM 成功的屏蔽掉了 mutable 的 DOM，每次 render 的 Component 其实都是新的，并不是以前 Component 的修改。
</p>

<p>
所以使用 Virutal DOM
</p>
<ul class="org-ul">
<li>容易 reason about， 因为 immutable</li>
<li>快</li>
<li>把紧耦合编程了高内聚</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">3</span> Why Immutable        / 为毛要不可变</h2>
<div class="outline-text-2" id="text-3">
<p>
Immutable 是函数式的概念之一，一旦创建出来之后，就不能再改变。因此，当你想对其做修改，就得弄一个新的。
</p>


<figure>
<p><img src="./images/zoidberg-die.gif" alt="zoidberg-die.gif">
</p>
</figure>

<p>
好奇的同学要问了，但是 React 看起来是面向对象的啊。 <code>createClass</code> ， <code>state</code> ，函数式有状态和 class 吗？
</p>

<blockquote>
<p>
If a tree falls in a forest and no one is around to hear it, does it make a sound? <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>
</blockquote>

<p>
首先，函数式和面向对象并不冲突，两种编程范式分别有各自的方式解决问题。
</p>

<p>
其次：
</p>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">3.1</span> 状态</h3>
<div class="outline-text-3" id="text-3-1">
<p>
如果状态只存在于 Component 中又并没有影响任何人，它还是状态吗？
</p>

<p>
ClojureScript 的 React 库 om，只有一个 app 级别的 state。因此所有的 component，其实并无状态。
</p>

<p>
<a href="https://youtu.be/5yHFTN-_mOo">https://youtu.be/5yHFTN-_mOo</a>
</p>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">3.2</span> Class</h3>
<div class="outline-text-3" id="text-3-2">
<p>
想象一下使用一个 React Component 的时候
</p>
<div class="org-src-container">

<pre class="src src-js">&lt;AFancyHelloWord message=<span style="color: #8b0000;">"Good News Everyone!"</span>/&gt;
</pre>
</div>
<p>
来想象一下
</p>
<ol class="org-ol">
<li>尖括号 <code>&lt;</code> 往右移</li>
<li>尖括号变成圆括号</li>
<li>里面再加个大括号</li>
<li>等号变冒号</li>
</ol>
<div class="org-src-container">

<pre class="src src-js">AFancyHelloWord({message:<span style="color: #8b0000;">"Good News Everyone!"</span>})
</pre>
</div>

<p>
<a href="./images/futurama_August_26__2015_at_0617AM.gif ">./images/futurama_August_26__2015_at_0617AM.gif </a>
ok, 如果把每个 Component 看成一个函数，为了我们的代码更好 reason about 而且更 loose couple，我们应该尽量要 <b>消除</b> 每一个 Component 的状态。
 这样在 Component 的树中，我们可以随意切换 Component，以 Star Wars 为例，Anakin 有两样东西，Luke 和光剑：
</p>


<figure>
<p><img src="images/react-tree.png" alt="react-tree.png">
</p>
</figure>

<p>
当 Anakin 变成 Darth Vader，光剑的颜色变红时，Darth Vadar 有 Luke 和 红色光剑。
</p>


<figure>
<p><img src="images/react-tree-swap.png" alt="react-tree-swap.png">
</p>
</figure>

<p>
实际上我们需要尽量减少 Component 中的状态，而且对着少数的状态，由于他们是我们的 source  of truth，并不希望他是 mutable 的，这样我很难知道谁动了我的 source of truth。
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">3.3</span> 让你的数据结构 immutable 的工具们</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><a href="http://facebook.github.io/react/docs/update.html">Immutablility helper</a></h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
这是 react addon 中自带的工具，如果你并不想完整的 Immutable 数据结构，这个工具可以帮助 copy 一份来做改动
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">update</span> = require(<span style="color: #8b0000;">'react-addons-update'</span>);
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">inc</span> = x=&gt;x+1
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">fancyPropsForChild</span>=update(<span style="color: #6b8e23;">this</span>.state, {
    x: {y: {z: {$set: 7}}},
    a: {b: {$push: [9]}},
    h: {$merge: {i: <span style="color: #8b0000;">"j"</span>}},
    e: {$apply: inc}
});
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><a href="https://github.com/swannodette/mori">mori</a></h4>
<div class="outline-text-4" id="text-orgheadline12">
<p>
更为彻底的选择是，使用 ClojureScript 的 Immutable 数据结构。benchmark 要比 facebook 的 Immutable.js 好上许多，但是使用上跟 ClojureScript 一致， 用惯JavaScript的人可能不太能习惯，alternative 是使用我 fork 的 mori 版本<a href="http://github.com/jcouyang/conjs">conjs</a>。
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-4">
<h4 id="orgheadline13"><a href="https://facebook.github.io/immutable-js/">Immutable.js</a></h4>
<div class="outline-text-4" id="text-orgheadline13">
<p>
facebook 实现的 immutable 数据结构，使用上比较符合 JavaScript 习惯一些， 不过跑分低一些。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19"><span class="section-number-2">4</span> How to do Unit test React project        /  如何单元测试</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">4.1</span> <a href="http://facebook.github.io/jest/">Jest</a></h3>
<div class="outline-text-3" id="text-4-1">
<p>
总的来说，jest 的测试理念解决了非常多的前端测试的棘手问题，我做过一个关于 jest 的 session， 文章在 <a href="https://gistdeck.github.com/jcouyang/34686f695cd28309759e">这里</a>。 文章可能写得有点早，非常知道高兴的是终于支持<a href="https://github.com/facebook/jest/blob/master/package.json#L34">最新的 nodejs 了</a>，而且 重要的是 facebook 使用 jest 测试 react，有一些非常方便的 mock component 的方法。
</p>

<p>
recap 一下主要是
</p>
<ul class="org-ul">
<li>automock/ manual mock</li>
<li>jsdom</li>
<li>并行测试</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">4.2</span> jasmine</h3>
<div class="outline-text-3" id="text-4-2">
<p>
jasmine  只是一个引擎，jest 也是用 jasmine 作为引擎。但是如果由于某种原因你不想用 jest 的话，可能你需要花更多的 effort 在：
</p>
<ul class="org-ul">
<li>mock （rewire.js）</li>
<li>runner (karma)</li>
<li>headless browser for ci(phantomjs)</li>
</ul>

<p>
所以并不推荐花这么大 effort 去撘一个 jasmine 的测试环境，关键还会有一系列的问题
</p>
<ul class="org-ul">
<li>phantomjs 怪怪的 issue</li>
<li>karma 复杂的配置</li>
<li>rewire 也有一些坑</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">4.3</span> mocha</h3>
<div class="outline-text-3" id="text-4-3">
<p>
没试过用来测 React，不过 mocha 比 jasmine 好的一点是本身就可以跑在 node 上，使用 sinon（mock） 和 should.js（assert） 是个非常强大的一套测试工具。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22"><span class="section-number-2">5</span> Modular and Components</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">5.1</span> browserify</h3>
<div class="outline-text-3" id="text-5-1">
<p>
简单的 modular  bundler， <b>推荐</b> ， 因为职责单一的工具更不容易遇到奇怪的问题。
</p>

<p>
使用 browserify 使用 <a href="https://babeljs.io/docs/setup/#browserify">babel transformer</a> 就可以把所有的 component 以 node 的方式模块化的组织，最后 bundle 成一个 js 文件。
</p>

<ul class="org-ul">
<li><a href="https://babeljs.io/docs/setup/#browserify">babel 官网</a>就说明了如何使用 browserify <i>babelify</i> 你的模块们</li>
<li>如果使用 <i>gulp</i> ，需要参考 gulp <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/browserify-uglify-sourcemap.md">这篇文档</a></li>
<li><i>grunt</i> 用户请使用 grunt-browserify 插件(非官方)</li>
<li><i>broccoli</i> 用户插件在 <a href="https://github.com/babel/broccoli-babel-transpiler">这里</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">5.2</span> webpack</h3>
<div class="outline-text-3" id="text-5-2">
<p>
以 grunt 的方式 browserify 你的代码，非常强大的 bundler。但是个人并不喜欢 grunt，karma，webpack 这种基于配置的工具，原因很简单，配置不是代码！配置不是代码！配置不是代码！ 配对了当然简单，但是配错了怎么办，没法 debug。
</p>

<p>
虽然不喜欢，我还是要告诉你怎么用，就这么一行配置就好了
</p>
<div class="org-src-container">

<pre class="src src-js">module: {
  loaders: [
    { test: <span style="color: #8b0000;">/\.jsx?$/</span>, exclude: <span style="color: #8b0000;">/node_modules/</span>, loader: <span style="color: #8b0000;">"babel-loader"</span>}
  ]
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-2">
<h2 id="orgheadline23"><span class="section-number-2">6</span> How should I thinking in react way / 如何以 React 的方式解决问题</h2>
<div class="outline-text-2" id="text-6">
<p>
要以 react 的方式思考，其实跟思考 HTML 差不多
 <a href="http://facebook.github.io/react/docs/thinking-in-react.html">http://facebook.github.io/react/docs/thinking-in-react.html</a>
</p>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-2">
<h2 id="orgheadline27"><span class="section-number-2">7</span> What about Data Fetching / 只有 V 的话，数据 M 呢</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24"><span class="section-number-3">7.1</span> just <a href="https://github.com/cujojs/rest">rest</a></h3>
<div class="outline-text-3" id="text-7-1">
<p>
简单，rest 请求回来一个 Promise，你还可以用 <a href="https://github.com/cujojs/when">when</a>  获得更多的 promise 和 monad 用法。
</p>

<p>
无需 model 在 componentDidMount 发出 rest 请求，then 直接扔给 setState。最多 setState 前加些 map filter 把数据改改格式。
</p>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25"><span class="section-number-3">7.2</span> <a href="https://facebook.github.io/relay/">relay/graphql</a></h3>
<div class="outline-text-3" id="text-7-2">
<p>
官方 data fetching 解决方案。
</p>

<p>
比起由 component 去发请求，再转换数据格式。relay/graphql 的思想是有 component 定义数据形状，由 relay 去发请求，有 graphql server 跟去根据定义返回相应形状的数据。
</p>

<p>
所以，对，会多一层 server layer。
</p>

<p>
view 层简单了，graphql 要做的事情却不少。
</p>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26"><span class="section-number-3">7.3</span> <a href="https://github.com/netflix/falcor">falcor</a></h3>
<div class="outline-text-3" id="text-7-3">
<p>
netflix 的简单版的 graphql可以参考我的 <a href="https://github.com/jcouyang/react-falcor">todo falcor</a>
思想大致相似，但是更为简单一些，没有什么 QL，schema 之类的
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-2">
<h2 id="orgheadline32"><span class="section-number-2">8</span> What about Router / router 怎么办</h2>
<div class="outline-text-2" id="text-8">
<p>
建议使用 isomorphic router，就是 browser 与 node 都可以用的 router
</p>
</div>
<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">8.1</span> <a href="https://github.com/flatiron/director">direactor</a></h3>
<div class="outline-text-3" id="text-8-1">
<p>
非常轻量级的通用 router，并不是专门为 react 准备的，但是 router 而已，为毛要跟 component 耦合。
</p>
</div>
<div id="outline-container-orgheadline28" class="outline-4">
<h4 id="orgheadline28">client side</h4>
<div class="outline-text-4" id="text-orgheadline28">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">routes</span> = {
  <span style="color: #8b0000;">'/author'</span>: ()=&gt;React.render(&lt;Author/&gt;, domNode),
  <span style="color: #8b0000;">'/author/:id'</span>: (id)=&gt;React.render(&lt;Auther id={id}/&gt;, domNode)
};
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">router</span> = Router(routes);
router.init();
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-4">
<h4 id="orgheadline29">server side</h4>
<div class="outline-text-4" id="text-orgheadline29">
<p>
只需要调用 router.dispatch 就好了, 而且 server 端的 react 需要 <code>renderToString</code>
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">router</span> = <span style="color: #00008b;">new</span> <span style="color: #36648b;">director.http.Router</span>({
  <span style="color: #8b0000;">'/author'</span>: {
    <span style="color: #6a5acd;">get</span>: <span style="color: #00008b;">function</span>(){
      <span style="color: #6b8e23;">this</span>.res.end(React.renderToString(&lt;Author/&gt;))
    }
  }
});
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">server</span> = http.createServer(<span style="color: #00008b;">function</span> (<span style="color: #b8860b;">req</span>, <span style="color: #b8860b;">res</span>) {
  router.dispatch(req, res, <span style="color: #00008b;">function</span> (<span style="color: #b8860b;">err</span>) {
    res.writeHead(200, { <span style="color: #8b0000;">'Content-Type'</span>: <span style="color: #8b0000;">'text/html'</span> })
    <span style="color: #00008b;">if</span> (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31"><span class="section-number-3">8.2</span> <a href="https://github.com/rackt/react-router">react router</a></h3>
<div class="outline-text-3" id="text-8-2">
<p>
非常 <b>非轻量级</b> 的 router，而且只能给 react component用。
</p>

<p>
概念上就是使用 Route 把你的 Component 包起来，让 router 决定到底哪个 componet 上
</p>
<div class="org-src-container">

<pre class="src src-js">render((
  &lt;Router&gt;
    &lt;Route path=<span style="color: #8b0000;">"/"</span> component={App}&gt;
      &lt;Route path=<span style="color: #8b0000;">"about"</span> component={About}/&gt;
      &lt;Route path=<span style="color: #8b0000;">"users"</span> component={Users}&gt;
        &lt;Route path=<span style="color: #8b0000;">"/user/:userId"</span> component={User}/&gt;
      &lt;/Route&gt;
      &lt;Route path=<span style="color: #8b0000;">"*"</span> component={NoMatch}/&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.body)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline39" class="outline-2">
<h2 id="orgheadline39"><span class="section-number-2">9</span> How to communicate between two components that don't have a parent-child relationship<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> / 不是父子关系的 component 怎么交互</h2>
<div class="outline-text-2" id="text-9">
<p>
对于这个问题，我的问题是
</p>
<blockquote>
<p>
如果不是父子关系或者兄弟或者伯父侄女，真的需要交互吗？
</p>
</blockquote>
<p>
如果是在同一颗树上，那么一定能找到一个共同的 parent，把 parent 的回调传进来就好了
</p>

<p>
如果不在同一颗树上，你可能需要一个全局的一些东西
</p>
</div>
<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33"><span class="section-number-3">9.1</span> event</h3>
<div class="outline-text-3" id="text-9-1">
<p>
 使用随便一种 event emitter，比如 <a href="https://www.npmjs.com/package/backbone-events-standalone">backbon events</a>。
在一个 componnet 中 trigger，另一个 component subscribe
</p>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36"><span class="section-number-3">9.2</span> flux</h3>
<div class="outline-text-3" id="text-9-2">
<p>
flux 只是一个架构思想，你可以用任何自己喜欢的方式实现
其实跟 event emitter 差不多，只是针对和管理 state
</p>
</div>

<div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34">dispatcher</h4>
<div class="outline-text-4" id="text-orgheadline34">
<p>
作为action 的分发工作，决定哪些 action 引起哪些 store 的变化
</p>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-4">
<h4 id="orgheadline35">store</h4>
<div class="outline-text-4" id="text-orgheadline35">
<p>
状态与逻辑
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">9.3</span> router</h3>
<div class="outline-text-3" id="text-9-3">
<p>
使用 router 传递信息也是可以的
</p>
</div>
</div>
<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">9.4</span> 应用级别 state</h3>
<div class="outline-text-3" id="text-9-4">
<p>
跟 om 一样，全局应用级别 state
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-2">
<h2 id="orgheadline40"><span class="section-number-2">10</span> When should I use "key" / 什么时候该用 key</h2>
<div class="outline-text-2" id="text-10">
<p>
<b>只有当出现一串一样的元素的时候</b> ，这个时候 Virtual DOM 去 reconciliate（搞） DOM 的时候会傻傻分不清楚。
</p>

<blockquote>
<p>
别的时候不要用 key，key 已经出现在 virtual dom diff/reconciliation 的阶段，效率要更低于 shouldComponentUpdate，所以尽量通过 shouldComponentUpdate 来决定是否要 render component。
</p>
</blockquote>


<figure>
<p><img src="./images/came-out.gif" alt="came-out.gif">
</p>
</figure>

<p>
官网文档的这个例子
</p>
<div class="org-src-container">

<pre class="src src-js">renderA: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;
renderB: &lt;div&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;
=&gt; [replaceAttribute textContent <span style="color: #8b0000;">'second'</span>], [insertNode &lt;span&gt;first&lt;/span&gt;]
</pre>
</div>
<p>
其实是往第一个位置插入了一个 span，但是会被 diff 成
</p>
<ul class="org-ul">
<li>替换内容 first 到 second</li>
<li><p>
插入内容为 first 的 span
</p>

<p>
不光是这样会更慢的问题，如果你在 first 上绑有事件的话，重新 render 后因为是 replace 了内容，因此这是原来的事件会变成 second 的事件，这样就 <b>完全错乱</b> 了。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-2">
<h2 id="orgheadline41"><span class="section-number-2">11</span> What's these Warnings / 这些黄黄的是神马</h2>
<div class="outline-text-2" id="text-11">
<blockquote>
<p>
黄黄的东西(除了小黄人)请一定要除掉！
</p>
</blockquote>
<p>
所有 react 的 warning 描述都非常详细，请一定 <b>务必</b> 要除掉。
</p>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-2">
<h2 id="orgheadline45"><span class="section-number-2">12</span> How to Profile Component Perfomance / 如何提升效率</h2>
<div class="outline-text-2" id="text-12">
<p>
当然不是咖啡!
</p>


<figure>
<p><img src="./images/coffee.gif" alt="coffee.gif">
</p>
</figure>
</div>

<div id="outline-container-orgheadline42" class="outline-3">
<h3 id="orgheadline42"><span class="section-number-3">12.1</span> <a href="https://facebook.github.io/react/docs/perf.html">react profile</a></h3>
</div>

<div id="outline-container-orgheadline43" class="outline-3">
<h3 id="orgheadline43"><span class="section-number-3">12.2</span> PureRenderMixin</h3>
<div class="outline-text-3" id="text-12-2">
<p>
当你的 props 和 state 都是 immutable 的时候&#x2026;
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">PureRenderMixin</span> = require(<span style="color: #8b0000;">'react-addons-pure-render-mixin'</span>);
React.createClass({
  mixins: [PureRenderMixin],
  <span style="color: #6a5acd;">render</span>: <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">return</span> &lt;div className={<span style="color: #6b8e23;">this</span>.props.className}&gt;foo&lt;/div&gt;;
  }
});
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-3">
<h3 id="orgheadline44"><span class="section-number-3">12.3</span> <a href="https://facebook.github.io/react/docs/advanced-performance.html#shouldcomponentupdate-in-action">shouldComponentUpdate</a></h3>
<div class="outline-text-3" id="text-12-3">
<p>
可以通过这个方法对于 component 到底什么情况下应该重新 render 调优
</p>


<blockquote>
<p>
所有图片来源于 giphy.com, copyright @<a href="http://www.cc.com/shows/futurama">Futurama</a>
</p>
</blockquote>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2">https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="http://facebook.github.io/react/tips/communicate-between-components.html">http://facebook.github.io/react/tips/communicate-between-components.html</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p>Author: Jichao Ouyang <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow @jcouyang</a></p>
<p>Modified: 2016-06-09 Thu 15:39</p>
<p>Generated by: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.3.4)</p>
<p>&lt;Publish&gt; with _(:з」∠)_ by <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.

<p class="org-center">
    <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
</p>
<p><a href="/index.xml">RSS</a> | <a href="/archive.html">ARCHIVE</a> | <a href="/theindex.html">INDEX</a> | <a href="#" id="edit-in-github">EDIT</a></p>

<a class="github-fork-ribbon right-bottom fixed" href="https://github.com/jcouyang/blog" title="Fork me on GitHub">Fork me on GitHub</a>

<script>
 (function(){
   document.getElementById('edit-in-github').addEventListener("click",function(){
     var pathname = window.location.pathname;
     window.location.href = "https://github.com/jcouyang/blog/edit/master/org"+pathname.replace(".html",".org");
   })
 })()
</script>
<!-- Google Analystics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32314154-10', 'auto');
  ga('send', 'pageview');

</script>
<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
 var disqus_shortname = 'orgblog';
 var href = window.location.href;
 href.replace(/^https/, 'http');
 var disqus_url = href;
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<!-- Swiftype Search -->
<script type="text/javascript">
 (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
     (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
     e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
 })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
 
 _st('install','eGLqWnAM75a66SiXKVW3','2.0.0');
</script>
</div>
</body>
</html>
