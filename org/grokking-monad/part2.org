#+TITLE: 范畴论完全装逼手册(二) / Grokking Monad
#+Date: <2017-02-10 Fri>
#+AUTHOR: 欧阳继超
#+OPTIONS: ^:t
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

- [[./index.org][第一部分：范畴论]]
- *[[./part2.org][第二部分：食用猫呢]]* 👈

第一部分理论部分都讲完了， 如果你读到这里还没有被这些吊炸天的概念搞daze，接下来可以看看它到底跟我们编程有鸟关系呢？

第二部分将介绍由这些概念产生的一些实用的monad instances，这些 monad 都通过同样的抽象方式，解决了分离计算与副作用的工作。

最后，我们还可以像 IO monad 一样，通过 free 或者 Eff 自定义自己的计算，和可能带副作用的解释器。

* TODO 第二部分：{{{ruby(食用猫呢, Practical Monads)}}}
一些有用的 Monad instances
** COMMENT Applicative
*** Alternative
*** Arrow
*** Bifunctor

** Identity
这可能是最简单的 monad 了。不包含任何计算
#+BEGIN_SRC haskell
newtype Identity a = Identity { runIdentity :: a } 
#+END_SRC
这里使用 =newtype= 而不是 =data= 是因为 =Identity= 与 =runIdentity= 是 isomorphic 的。

#+BEGIN_SRC haskell
Identity :: a -> Identity a
runIdentity :: Identity a -> a
#+END_SRC

** Maybe
这是一个再简单的 Monad，首先，需要定义这个一个 {{{ruby(代数数据类型, Algebra Data Type(ADT))}}}
#+BEGIN_SRC haskell
data Maybe a = Just a | Nothing
#+END_SRC
Haskell中定义一个ADT十分简单，不像Scala那么啰嗦。左边是类型，右边有类型构造器，你会发现有一根竖线 =|= ， 它分隔着两个构造器
- Just a
- Nothing
其中 a （一定要小写）可以是任意类型

所以 =Just 1= 会得到一个 =Num a => Mabye a= 类型（意思就是 =Maybe a= 但是 =a= 的类型约束为 =Num= ）， =Nothing= 也会得到一个 =Maybe a= 只不过 =a= 没有类型约束。

总之我们有了构造器可以构造出 Maybe 类型，而这个类型能做的事情，就要取决它实现了哪些 class 的 instance 了。


** Either

*** /Coproduct/
注意到两个构造器的类型分别为
- Just:: a -> Maybe a
- Nothing:: Maybe a

*** 
比如： Monad
#+BEGIN_SRC haskell
  instance Monad Maybe where
    Just a >>= f = f a
    Nothing >>= f = Nothing
#+END_SRC

** Validate
** Reader
给一个computation喂数据
输入 r
asks 可以通过函数 r->a 得到一个 Reader r a monad
#+BEGIN_SRC haskell
asks :: (r -> a) -> Reader r a
runReader :: Reader r a -> r -> a

import Control.Monad.Reader

data MyContext = MyContext
  { foo :: String
  , bar :: Int
  } deriving (Show)

computation :: Reader MyContext (Maybe String)
computation = do
  n <- asks bar
  x <- asks foo
  if n > 0
    then return (Just x)
    else return Nothing

ex1 :: Maybe String
ex1 = runReader computation $ MyContext "hello" 1

ex2 :: Maybe String
ex2 = runReader computation $ MyContext "haskell" 0
#+END_SRC
** Writter
除了返回值，computation会写一些额外的数据

返回值会是一个这样 =(result, log)= 的 tuple

限制是 log 的类型必须是个 monoid

#+BEGIN_SRC haskell
example  = do
  tell [1..3]
  tell [3..5]
  return "foo"

output :: (String, [Int])
output = runWriter example
-- ("foo", [1, 2, 3, 3, 4, 5])
#+END_SRC
** State

** RWS
** Expection
** Monad Transform
** Cont
** MonadPlus
** MonadFix
** ST
** Free Monad
** Eff

** References
- https://wiki.haskell.org/All_About_Monads
