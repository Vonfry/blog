#+TITLE: Essential EcmaScript 6 [%]
#+DATE: <2015-03-16 Mon>

* Arrow Function
来看看越来越函数式の JavaScript

新的草案[[http://kangax.github.io/compat-table/es6/][ECMAScript 6]]
(虽然说是草案,但你可以看到 Firefox 其实已经实现大部分的
feature)都支持什么吧。

我們先來看看 arrow
function，为什么叫箭头函数，如果之前用过
Haskell(单箭头) 或者Scala(双箭头), 会发现都用的是箭头来表示简单映射关系函数.

#+BEGIN_QUOTE
由于 arrow function 只在Firefox 22以上版本实现,
本节的所有代码都可以在Firefox的Console中调试, 其他chrome 什么的都没有实现(完全)[fn:1].
另外每节的最后我都会给出完整代码的可执行的 jsbin 链接.
#+END_QUOTE

*** 声明一个箭头函数

你可以用两种方式定义一个箭头函数

#+BEGIN_SRC
    ([param] [, param]) => {
       statements
    }
    // or
    param => expression
#+END_SRC

单个表达式可以写成一行, 而多行语句则需要 block ={}= 括起来.

*** 为什么要用箭头函数

看看旧的匿名函数怎么写一个使数组中数字都乘2的函数.

#+BEGIN_EXAMPLE
    var a = [1,2,3,4,5];
    a.map(function(x){ return x*2 });
#+END_EXAMPLE

用箭头函数会变成

#+BEGIN_EXAMPLE
    a.map(x => x*2);
#+END_EXAMPLE

只是少了=function= 和=return= 以及 block, 不是吗? 如果觉得差不多,
因为你看惯了 JavaScript 的匿名函数,
你的大脑编译器自动的忽略了,因为他们不需要显示的存在.

而=map(x => x*2)= 要更 make sense,
因为我们需要的匿名函数只需要做一件事情, 我们需要的是 一个函数 =f=,
可以将给定 =x=, 映射到 =y=.
翻译这句话的最简单的方式不就是=f = (x => x*2)=

*** Lexical =this=

如果你觉得这还不足以说服改变匿名函数的写法,
那么想想以前写匿名函数中的经常需要=var self = this=的苦恼.

#+BEGIN_SRC javascript
    var Multipler = function(inc){
      this.inc = inc;
    }
    Multipler.prototype.multiple = function(numbers){
      return numbers.map(function(number){
        return this.inc * number;
      })
    }
    new Multipler(2).multiple([1,2,3,4]) // => [NaN, NaN, NaN, NaN]  不 work, 因为 map 里面的 this 指向的是全局变量( window)

    Multipler.prototype.multiple = function(numbers){
      var self = this; // 保持 Multipler 的 this 的缓存
      return numbers.map(function(number){
        return self.inc * number;
      })
    }
    new Multipler(2).multiple([1,2,3,4]) // => [ 2, 4, 6, 8 ]
#+END_SRC

很怪不是吗, 确实是 Javascript 的一个 bug, 因此经常出现在各种面试题中.

试试替换成 arrow function

#+BEGIN_SRC javascript
    Multipler.prototype.multiple = function(numbers){
      return numbers.map(number => number*this.inc);
    };

    console.log(new Multipler(2).multiple([1,2,3,4]));// => [ 2, 4, 6, 8 ]
#+END_SRC

不需要 =var self = this= 了是不是很开心☺.现在, arrow function 里面的
this 会自动 capture 外层函数的=this= 值.

[[http://jsbin.com/vawobe/2/edit?js][完整代码]]
* Proxy
名字解释了一切, 对, 代理, 就是能帮你做一些事情的东西.

JavaScript是动态语言,也就是说最关心的事情是行为.所以行为也能通過meta programming让其带那么一些行为.

试试把下列代码考到Firefox的Console中
#+BEGIN_SRC javascript
  let do_something = function(){
    return "doing something"
  }
  let fancy_do_something = new Proxy(do_something, {
      apply: function(receiver, that, args){
        console.log(`fancy ${receiver(args)}`)
      }
  })

  fancy_do_something()
#+END_SRC



* Destructuring

* Tail Calling

* Template Strings

* Class

* Symbols

* Let

* Promises

* Generator

[fn:1] Chrome有一个 feature toggle 可以打开部分 es6 功能 [[chrome://flags/#enable-javascript-harmony]]
