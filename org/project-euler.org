#+TITLE: Project Euler
#+PROPERTY: header-args :results value pp :exports both
#+INFOJS_OPT: view:info toc:nil
#+DATE:<2016-08-02 Tue>
#+SUBTITLE: 闲来无事 +七周+ 七语言撸一把 [[https://projecteuler.net/][*爱撸者计划* （ProjectEuler）]]

* COMMENT require
#+BEGIN_SRC emacs-lisp
  (require 'ob-clojure)
  (require 'ob-ruby)
  (require 'ob-js)
  (require 'ob-haskell)
  (require 'ob-scala)
  (require 'ob-python)
  (require 'ob-haskell)
#+END_SRC

#+RESULTS:
: ob-haskell

* Multiples of 3 and 5

求可被3或5整除的数字之和，比如0-100内的可被3或5整除的整数和为2318
** Clojure
- 直白解法 O(n)
#+BEGIN_SRC clojure :results value pp
  (def num-divby-3-5
    (filter (fn [n]
              (let [by3 (mod n 3) by5 (mod n 5)]
                (or (= 0 by3) (= 0 by5))
                ))))
  (defn sum-of-div-3-5 [n]
    (transduce num-divby-3-5 + (range n)))
  (sum-of-div-3-5 100)
#+END_SRC

#+RESULTS:
: 2318

- 数学一点点 O(n)
#+BEGIN_SRC clojure :results value pp
  (def by-3 (range 0 100 3))
  (def by-5 (range 0 100 5))
  (def by-15 (range 0 100 15))
  (- (+ (reduce + by-3) (reduce + by-5)) (reduce + by-15))
#+END_SRC

#+RESULTS:
: 2318

- 高效纯数学 O(1)
#+BEGIN_SRC clojure
  (defn sum-divby [num n]
    (let [end (quot num n)]
      (* n (quot (* end (inc end)) 2))))
  (- (+ (sum-divby 100 3) (sum-divby 100 5)) (sum-divby 100 15))
#+END_SRC

#+RESULTS:
: #'user/sum-divby2418

** Ruby
#+BEGIN_SRC ruby
(1..99).select{|x| x % 3 == 0 or x % 5 == 0}.reduce :+
#+END_SRC

#+RESULTS:
: 2318

** Scala
#+BEGIN_SRC scala
val by3 = 0 until 100 by 3
val by5 = 0 until 100 by 5
val by15 = 0 until 100 by 15
by3.sum + by5.sum - by15.sum
#+END_SRC

#+RESULTS:
: 2318

** Haskell
#+BEGIN_SRC haskell
let by3 = [0, 3..99]
let by5 = [0, 5..99]
let by15 = [0, 15..99]
sum by3 + sum by5 - sum by15
#+END_SRC

#+RESULTS:
: 2318

#+BEGIN_QUOTE
如果是haskell 没有副作用所以搞IO的话有稍稍麻烦
#+BEGIN_SRC haskell
import Control.Monad
import Data.List
readInt :: IO Int
readInt = readLn

getInputs :: Int -> IO [Int]
getInputs lines = replicateM lines readInt

solution n =
    blah blah blah...

main = do
  times <- readInt
  inputs <- getInputs times
  putStrLn $ intercalate "\n" $ map (show . solution) inputs
  
#+END_SRC
#+END_QUOTE

** JavaScript
#+BEGIN_SRC js :results output pp
  function sumDivBy(by, to) {
      let end = Number.parseInt(to / by)
      return by * (1 + end) * end / 2
  }
  console.log(
      sumDivBy(3, 99) + sumDivBy(5, 99) - sumDivBy(15, 99)
  )

#+END_SRC

#+RESULTS:
: 2318

** Python
#+BEGIN_SRC python :results output pp
  def sumDivBy(by, to):
      end = to/by
      return by * (1 + end) * end / 2
    
  print sumDivBy(3, 99) + sumDivBy(5, 99) - sumDivBy(15, 99)
#+END_SRC

#+RESULTS:
: 2318

明显看出 Haskell 跟 Scala 的表现力爆表，下题开始从Haskell开始好了


* #2 Even Fibonacci numbers
#+BEGIN_CENTER
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
#+END_CENTER

** Haskell
#+BEGIN_SRC haskell
evenFibonacci = zipWith (\x y -> x*4+y) (2:evenFibonacci) (0:2:evenFibonacci)
sum $ 0:2:(takeWhile (4000000>) evenFibonacci)
#+END_SRC

#+RESULTS:
: 4613732

* COMMENT #3
#+BEGIN_SRC haskell
prime_factors :: Int -> [Int]

prime_factors 1 = []
prime_factors n
  | factors == []  = [n]
  | otherwise = factors ++ prime_factors (n `div` (head factors))
  where factors = take 1 $ filter (\x -> (n `mod` x) == 0) [2 .. n-1]
#+END_SRC

* To be continue ...
