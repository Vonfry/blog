#+Title: 3 Layer Scala Cake
#+Date: <2019-03-18 Mon>
#+Language: en
#+Author: Jichao Ouyang
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

I've been using Free Monad in production for a while, as the projects scale and more
members contribute, the boundary of different layer reveal them self more clearly.

Thanks the summary from [[https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html][Matt Parsons' 3 layer Haskell Cake]]. I found my Scala code also happen to
fell into these 3 layer cake. 
To make the future project has more clear boundary of abstraction, I created [[https://github.com/jcouyang/luci][{{{ruby(鸬鹚,luci)}}}]]
for better taste of Free Monad effects.

Here it is the Scala version of Cake, prepare your folk please.

But before cutting the cake, let's +wash our hands+ describe the most common program.

* the Program
It will read output a log, query a data base, and do the calculation.

#+BEGIN_SRC scala
  val xa = Transactor.fromDriverManager[IO]("org.postgresql.Driver", "jdbc:postgresql:postgres", "postgres")
  def program : Int = {
    val initState = 1
    getLogger.log(s"init state is $initState")
    val valueInDatabase = try{
      sql"select 32".query[Int].unique.transact(xa) unsafeRunSyn ()
    } catch { case _: Throwable => 0}
    initState + valueInDatabase
  }
#+END_SRC

Your real business logic might be fancier, but basically this is the most common case

1. Something to ask
2. Something to write
3. Some effects on dependencies
4. Some error to handle
5. Some business computation

Anyway, this is really awful piece code in production.

First of all, how do you unit test such thing? Oh, wait, maybe not that awful, we just mock =getLogger= and stub it's =log= method
and then mock doobie's =ConnectionIO= and stub =transact= method.

Sounds reasonable, just 2 mocks and 2 stubs.

But think about it, here is just 2 line of effectful operation, count again such effectful code in production,
how many mocks and stub you will need then?

Such way of unit testing is definitely not gonna scale.

Let us refactor in a baby step, with =IO=
* Refactor
** Take 1: IO
modeling your problem with =IO= is easy, just wrap everything in IO

#+BEGIN_SRC scala
  def program : IO[Int] = for {
    initState <- IO(1)
    _ <- IO(getLogger.log(s"init state is $initState"))
    valueInDatabase <- sql"select 32".query[Int].unique.transact(xa)
      .handleError{_=>0}
  } yield initState + valueInDatabase
#+END_SRC

How the hell this is better than previous one?

Yes and No.

It's not better in the sense of testable, but, it's /Pure/

When we mention something that is Pure, it means that thing is Referential Transparent.

In human words, it means I can do this:

#+BEGIN_SRC scala
val logState = IO(getLogger.log(s"log something"))
def program : IO[Unit] = for {
  _ <- logState
  _ <- logState
  _ <- logState
} yield ()
#+END_SRC

But you can't do:
#+BEGIN_SRC scala
val logState = getLogger.log(s"log something")
def program : Int = {
  logState
  logState
  logState
}
#+END_SRC

Probably not the best example but you should get the idea, that I can place IO anywhere
and that won't change the semantic and behavior of your program.

Fine, let's place those IO else where, so we can inject them into program

#+BEGIN_SRC scala
  def program(getState: IO[Int], log: String => IO[Unit], queryDB: IO[Int]): IO[Int] = for {
    initState <- getState
    _ <- log(s"initState is: $initState")
    valueInDatabase <- queryDB
  } yield initState + valueInDatabase
#+END_SRC

Now it's better, in our test, we could simply testing =program= like
#+BEGIN_SRC scala
program(IO(1), (msg: String)=>IO(()), IO(10)) must_== 11
#+END_SRC

to verify our program can do the math.

But still, it won't scale, e.g. we need to query 3 value from db
#+BEGIN_SRC scala
def program(getState: IO[Int], log: String => IO[Unit], queryDB: IO[Int], queryDB2: IO[Int], queryDB3: IO[Int]): IO[Int] = for {
    initState <- getState
    _ <- log(s"initState is: $initState")
    valueInDatabase1 <- queryDB1
    valueInDatabase2 <- queryDB2
    valueInDatabase3 <- queryDB3
  } yield initState + valueInDatabase1 + valueInDatabase2 + valueInDatabase3
#+END_SRC

our program will end up very long parameters

Clearly IO isn't enough for more complex scenario, let's see what we can improve by adding another layer of abstraction

** Take 2: ReaderT Pattern
The problem of Dependent Injection via parameters is limited and not scalable, when your program get bigger,
eventually you will need to have sub programs and then you will find the dependency has to be passed all the way down
to each sub program.

Here's the ReaderT pattern to help.

First we move all dependency out, let's model it as =trait Env=
#+BEGIN_SRC scala
  trait Env{
    val state: Int
    def log(msg: String): IO(Unit)
    def query[A](c: ConnectionIO[A]): IO[A]
  }
#+END_SRC

Then we can move parameters of =program= out as standalone methods:
#+BEGIN_SRC scala
  def log(msg: String): ReaderT[IO, Env, Unit] = for {
    env <- Kleisli.ask[IO, Env]
    _ <- Kleisli.liftF(env.log(msg))
  } yield ()

  def doobieQuery[A](query: ConnectionIO[A]): ReaderT[IO, Env, A] = for {
    env <- Kleisli.ask[IO, Env]
    res <- Kleisli.liftF(env.query(query))
  } yield res
#+END_SRC

These methods just return data type that describe that they need a =Env= but not provided yet,
so you could put it anywhere you want, without knowing where exactly the instance of =Env= is.

Finally, the program, without any parameters!!!

#+BEGIN_SRC scala
  def program: ReaderT[IO, Env, Int] = for {
    env <- Kleisli.ask[IO, Int]
    initState = env.state
    _ <- log(s"initState is: $state")
    valueInDatabase <- doobieQuery(sql"select 32".query[Int].unique)
  } yield initState + valueInDatabase
#+END_SRC

** Retro
Let us retro the evolving progress of the type of =program=

*** Imperative
#+BEGIN_SRC scala
def program: Int
#+END_SRC
I'd name this layer *Bare Metal*. here only exists raw values, 0 abstraction

*** IO
#+BEGIN_SRC scala
def program(deps...): IO[Int]
#+END_SRC

Introduce a new layer of abstraction =IO=, and I'd like to name it *VM* layer

It's better than Bare metal, but still low level abstraction.

when we need value, just run the IO layer
#+BEGIN_SRC scala
program(deps...).unsafeRunSync()
#+END_SRC

Effects are now Referential Transparent, but the way to inject and use effects is not scalable.

*** ReaderT

#+BEGIN_SRC scala
def program: ReaderT[IO, Env, Int]
#+END_SRC

=ReaderT[IO, Env, Int]= consists 2 layers, =IO= and =Reader[Env, Int]=, this is the layer of *Functional Programming*

pure business, 0 effect, lazy

#+BEGIN_SRC scala
  program // <- ReaderT[IO, Env, Int]
  .run(new Env{
    val state = 1
    def log(msg: String) = IO(getLogger.log(msg))
    def query[A](c: ConnectionIO[A]) = c.transact(xa)
  }) // <- IO[Int]
  .unsafeRunSync() // <- Int
#+END_SRC

We need to run this layer by layer, first =Reader=, and then =IO=

and the time we run =Reader= can provide all the dependencies.

ReaderT is pretty good "pattern" after all:
- *Pure*: effectful part is factor out of program into Env (Bare Metal), so program can be Pure and RT
- *Modular*: Dependency Injections are happened in Monad context, scalable in sense of easy to break program into smaller sub program
- *Data Type*: since ReaderT is just a Data Type, lots of benefits for free from ReaderT's typeclasses instances, such as =Monoid=, =Applicative=, =MonadError=...

** Tagless Final is nothing but a fancy name of ReaderT
if we make some type alias for readerT, it's pretty much the same thing as the recent trending "design pattern" - /Tagless Final/
#+BEGIN_SRC scala
  trait AlgInterp[F[_]] {
    val state: F[Int]
    def log(msg: String): F[Unit]
    def query[A](c: ConnectionIO[A]): F[A]
  }

  type Alg[F[_], A] = ReaderT[F, AlgInterp[F], A]

  def state[F[_]]: Alg[F, Int] = Kleisli(_.state)
  def log[F[_]](msg: String): Alg[F, Unit] = Kleisli(_.log(msg))

  def doobieQuery[F[_], A](query: ConnectionIO[A]): Alg[F, A]

  def program[F[_]]: Alg[F, Int] = for {
    env <- state
    _ <- log(s"initState is: $state")
    valueInDatabase <- doobieQuery(sql"select 32".query[Int].unique).handleError{_=>0}
  } yield initState + valueInDatabase

 val interp = new AlgInterp[IO]{
    val state = IO(1)
    def log(msg: String) = IO(getLogger.log(msg))
    def query[A](c: ConnectionIO[A]) = c.transact(xa)
  }
  program[IO].run(interp).unsafeRunSync()
#+END_SRC

If you look close enough, here it actually becomes 3 layers:
- Layer 1: IO (AlgInterp)
- Layer 2: IO ~> Alg (state, log, doobieQuery)
- Layer 3: Alg (program)

both layer 2 and 3 are pure, but the different is,
- Layer 2 is just 1-1 mapping from IO to Alg
- Layer 3 is orchestration of Layer 2 for pure business

* 3 Layer Cake
We now have a solid 3 Layer Scala Cake base made of =ReaderT=

But you know, single flavor of cake won't satisfy everyone's taste.

** The Needs of State
remember the 5 factors that compose our program?
1. Something to ask
2. Something to write
3. Some effects on dependencies
4. Some error to handle
5. Some business computation

it has a missing part - Some *state*!

in a 5 lines of code program, you won't see a state is necessary.

in the real world, there are so many scenario needed a state

i.e. a user's login info

supposed that our program has a middleware, controller, repository layer

usually we will need to get user's info in middleware, and use the user info in repository layer for some database query.

so, here is the case, since I want a modular code base, so these 3 layers should not be just single =Alg[F]=, but 3

In Http4s, it would be something like:
#+BEGIN_SRC scala
def middleware[F[_]]: Kleisli[OptionT[F, ?], Request[F], Request[F]] = ???
def controller[F[_]]: Kleisli[OptionT[F, ?], Request[F], Response[F]] = ???

val program = middleware[IO] andThen controller[IO]
#+END_SRC
=controller= would probably call repository to query db

Damn, the middleware will return =Request[F]=, how can I pass user info through to controller and then repository

mutating request? but you can only put some header stuff, of transform the body.

than you have to get the info out, and snap it into repsoitory.

someday your controller become bigger and bigger and tech lead said there should be another layer - service, between controller and repository

then it will become a nightmare that you have to pass such thing all over your code base.

But that's exactly State Monad solve, not matter how many State monad you split, every piece alway can share the exactly same state.

But, but http4s routers are ReaderT!!!


** Layer 2: Effect ~> ReaderT[IO, Env, ?]

** Layer 3: Pure Fantasy
